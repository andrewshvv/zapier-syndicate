// File automatically generated by protoc-gen-sol and changed by hand.
// SPDX-License-Identifier: CC0
pragma solidity ^0.8.0;

import "@lazyledger/protobuf3-solidity-lib/contracts/ProtobufLib.sol";

struct Credential {
    uint32 winner;
    uint32 place;
    uint32 category;
}

library CredentialCodec {
    function decode(
        uint64 initial_pos,
        bytes memory buf,
        uint64 blen
    )
        internal
        pure
        returns (
            bool,
            uint64,
            uint32[] memory
        )
    {
        // Decoded values
        uint32[] memory values;
        // Field number
        uint64 field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        bool success;
        uint32 val;

        // Sanity checks
        if (pos + blen < pos) {
            return (false, pos, values);
        }

        // Extract values arrays length as first value
        uint32 length;
        (success, pos, field_number, length) = decode_value(
            pos,
            field_number,
            buf
        );
        if (!success) {
            return (false, pos, values);
        }

        // Initit values array
        values = new uint32[](length);

        uint32 i = 0;
        while (pos - initial_pos < blen && i < length) {
            (success, pos, field_number, val) = decode_value(
                pos,
                field_number,
                buf
            );
            if (!success) {
                return (false, pos, values);
            }

            values[i] = val;
            i++;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + blen) {
            return (false, pos, values);
        }

        return (true, pos, values);
    }

    function decode_value(
        uint64 pos,
        uint64 previous_field_number,
        bytes memory buf
    )
        internal
        pure
        returns (
            bool,
            uint64,
            uint64,
            uint32
        )
    {
        bool success;
        uint64 field_number;
        uint32 val;

        // Decode the key (field number and wire type)
        ProtobufLib.WireType wire_type;
        (success, pos, field_number, wire_type) = ProtobufLib.decode_key(
            pos,
            buf
        );
        if (!success) {
            return (false, pos, field_number, 0);
        }

        // Check that the field number of monotonically increasing
        if (field_number <= previous_field_number) {
            return (false, pos, field_number, 0);
        }

        // Check that the wire type is correct
        if (wire_type != ProtobufLib.WireType.Varint) {
            return (false, pos, field_number, 0);
        }

        // Actually decode the field
        uint32 v;
        (success, pos, v) = decode_uint32(pos, buf);
        if (!success) {
            return (false, pos, field_number, val);
        }

        return (true, pos, field_number, v);
    }

    function decode_uint32(uint64 pos, bytes memory buf)
        internal
        pure
        returns (
            bool,
            uint64,
            uint32
        )
    {
        bool success;

        uint32 v;
        (success, pos, v) = ProtobufLib.decode_uint32(pos, buf);
        if (!success) {
            return (false, pos, v);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos, v);
        }

        return (true, pos, v);
    }
}
